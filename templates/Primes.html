<!DOCTYPE html>

{% macro msub(a, b, math=1) -%}
	<math>
		<msub>
			<mi>{{a}}</mi>
			<mi>{{b}}</mi>
		</msub>
	</math>
{%- endmacro %}

{% macro msup(a, b, math=1) -%}
	<math>
		<msup>
			<mi>{{a}}</mi>
			<mi>{{b}}</mi>
		</msup>
	</math>
{%- endmacro %}




<head>
	<meta charset = "UTF-8">
	<link rel="stylesheet" type="text/css" href={{url_for('static', filename='Primes.css')}}>
</head>

<body>
	<div id="Theory">
		Let's say I have q queries <math>(q&lt;1000000)</math> whether given number <math>{{msub("a","i")}} ({{msub("a","i")}}&lt;1000000)</math> is prime. To answer these problems, first let's define prime number: a number <math>k&#x2208;{{msup("N","+")}}</math> is prime, if and only if<br><br>
		<center><math>k&#x2208;P &#x21D4; <msub><mrow>&#x2203;&#x0021;</mrow><mrow>x&#x2208;<msup><mi>N</mi><mi>+</mi></msup>\{1}</mrow></msub> k&#x2261;0 mod x</math><br><br></center>
		where {{msup("N","+")}} is set of natural numbers excluding 0, P is set of primes. In other words, k needs to have exactly 1 natural divisor different than one - itself. A number k is divisible by m, if and only if:<br><br>
		<center>m|k &#x21D4; &#x2203;<sub>x&#x2208;N<sup>+</sup></sub> m*x=k<br><br></center>

		For example, 2, 3, 5, 31 are prime numbers. The first solution that can be discussed is absolute brute force
	</div><br>
		<div id="sol1">We can check for number given in i-th query, whether it's prime by checking whether any number x&#x2208;&lt;2;a<sub>i</sub>-1&gt; is it's divisor: if it is, then we know it's not prime this solution works in O(q*max(a<sub>i</sub>), which is obvious if all numbers given in queries are prime - we have to check n numbers whether they have divisor, and we check it in O(a<sub>i</sub>).
	</div><br>

	<div id="sol2">
		We can notice, that if k is not prime and a is it's divisor&gt;1 and &lt;k, then either a or k/a are &lt;=<math><msqrt><mi>k</mi></msqrt></math>; proof by contradiction is trivial: let's assume, that a|k; then, there exists such natural b, that b*a=k; if a&gt;<math><msqrt>k</msqrt></math> and m&gt;<math><msqrt>k</msqrt></math>, then a*b&gt;<math><msqrt>k</msqrt></math>*<math><msqrt>k</msqrt></math>=k; if one of them is equal to <math><msqrt>k</msqrt></math>, then, by definition, second must be equal to <math><msqrt>k</msqrt></math> too, which finishes the proof. <br> And so, we need to check only <math><msqrt><msub><mi>a</mi><mi>i</mi></msub></msqrt></math> values to check whether a<sub>i</sub> is prime. That makes the algorithm run in O(q*<math><msqrt>max(<msub><mi>a</mi><mi>i</mi></msub>)</msqrt></math>)
	</div><br>

	<div id="sol3">However, we can solve problem offline: one can just create array p[1000000], take subsequent prime numbers starting from 2 and mark all numbers divisible by it as non-primes; then go to the next prime number (3), repeat procedure, and so on, as on animation:
	</div>
	
	<div id="Algo1">
		<h2>Sieve</h2>
		<div id="Inputter">
			<form>
				<input type="number" class="inputter" id="Erasto" name="Erasto" value="99">
			</form>
			<button id="Sender" class="sender">Begin</button>
			<button id="Prever" class="previous">Previous Move</button>
			<button id="Nexter" class="next">Next Move</button>
			<button id="Finisher" class="finish">Finish</button>
		</div>
		<div class="breakAlgo"></div>
		<div id="Primez" class="primez"></div>
		<div id="Comprehend" class="comprehend"></div>
	</div>

	<div id="Anime-Descr">
	Begin starts the sieve with a given limit. Next move moves forward current sieve, Previous move moves backward. This sieve has 2 optimizations: first, if a number is marked as non-prime, then we don't have to mark numbers divisible by it, because they were already marked by it's divisor. Proof:<br><br>
	<center>a|b &#x2227; b|c &#x21D2; &#x2203;<sub>k, l &#x2208;N</sub> k*a=b &#x2227; l*b=l*k*a=c &#x21D2; a|c</center><br><br>

	Secondly, for given x, No composite number lower than x*x has lowest divisor d&gt;1 greater or equal to x, which was shown in 2nd solution to this problem. 
	</div>
	<div id="Complexity">
		It can be easily proven, that sieve, even without any optimizations works in O(n*log(n)): In each operation, one either searches for next prime number: sum of all searches is just linear walk from the beginning to the end of table, so it's linear; or marking numbers. Marking numbers works in O(n*log(n)), because it's sum of iterations on the table with difference 2: when sieve marks numbers divisible by 2, it makes <math><mfrac><mi>n</mi><mi>2</mi></mfrac></math> iterations; when it marks numbers divisible by 3, it makes <math><mfrac><mi>n</mi><mi>3</mi></mfrac></math> iterations, etc. So, algorith makes:
		<br>
		<center>

			<math>
			{% for i in [2, 3, 5, 7, 11, 13] %}
				<mfrac><mi>n</mi><mi>{{i}}</mi></mfrac><mo>+</mo>
			{% endfor %}
			...+<mfrac><mi>n</mi><mi>mp</mi></mfrac><mo>≤</mo>
			{% for i in range(2, 8) %}	
				{% if i==2 or i==4 %}
					<munder><mrow>
				{% endif %}
				<mfrac><mi>n</mi><mi>{{i}}</mi></mfrac>
				{% if i==3 or i==7 %}
					</mrow><mo> &#x23DF; <!--BOTTOM CURLY BRACKET--> </mo></munder>
				{% endif %}
				<mo>+</mo>
			{% endfor %}
			...+<mfrac><mi>n</mi><mi>n</mi></mfrac><mo>≤</mo>

			{% for i in range(1, 4) %}
				<munder><mrow>
				{% set s=jipow(2, i) %}
				{% for j in range(s) %}
					<mfrac><mi>n</mi><mi>{{s}}</mi></mfrac>
					{% if (j!=s-1) %}
						<mo>+</mo>
					{% endif %}
				{% endfor %}
				</mrow><mo> &#x23DF; <!--BOTTOM CURLY BRACKET--> </mo></munder>
				<mo>+</mo>
			{% endfor %}
			...+<mfrac><mi>n</mi><mi>n</mi></mfrac><mo>≤</mo>

			{% for i in range(1, 4) %}
				{% set s=jipow(2, i) %}
				<mi>{{s}}</mi><mo>*</mo><mfrac><mi>n</mi><mi>{{s}}</mi></mfrac>
				<mo>+</mo>
			{% endfor %}
			...+<msup><mi>2</mi><mi>&#x230A;<msub><mi>log</mi><mi>2</mi></msub>(n)+1&#x230B;</mi></msup>
			<mo>*</mo><mfrac>
				<mrow><mi>n</mi></mrow>
				<mrow>
					<msup>
						<mi>2</mi>
						<mn>&#x230A;
							<msub>
								<mi>log</mi>
							<mn>2</mn></msub>(n)+1&#x230B;
						</mn>
					</msup>

				</mrow>
			</mfrac>
			<mo>=</mo>

			<math display='inline'>
			  <munderover>
			    <mo>&Sum;</mo>
			    <mrow>
				<mi>i</mi>
				<mo>=</mo>
				<mn>1</mn>
			    </mrow>
			    <mi>log2(n)+1</mi>
			  </munderover>
			  <mfenced separators=''>
				<msup><mi>2</mi><mi>i</mi></msup><mo>*</mo>
				<mfrac>
					<mrow><mi>n</mi></mrow>
					<mrow>
						<msup>
							<mi>2</mi>
							<mn>i</mn>
						</msup>
					</mrow>
			    	</mfrac>
			  </mfenced>
			</math>
			<mo>=</mo>

		<math display='inline'>
			<mi>n*</mi>
			<munderover>
				<mo>&Sum;</mo>
				<mrow>
					<mi>i</mi>
					<mo>=</mo>
					<mn>1</mn>
				</mrow>
			    	<mi>log2(n)+1</mi>
			</munderover>
			<mfenced separators=''>
			  	1
			</mfenced>
		</math>
			<mo>=</mo>
			<mi>n*(log2(n)+1)</mi>
			<mo>=</mo>
			<mi>O(n*log(n))</mi>
			</math>
		</center>
		<br>
		<div>
		But there is also simpler proof with assumtion, that we only mark numbers after we stumble upon a prime number (e.g., after marking 4, we don't start marking 8, 12, 16, 20, etc.). How many times one number can be marked using that optimization? It will be marked by all it's prime components only once: so, 16=2*2*2*2 will be marked once, because it has one distinct prime component(2).  On the other hand, 4800=2*2*2*2*2*2*3*5*5 will be marked at most thrice, because it has three distinct prime divisors (2, 3, 5). Ultimately, a number x cannot be marked more times than log2(x). So, if max(a<sub>i</sub>)≤K, then complexity of this sieve is O(n*s), where s is maximal number of distinct prime divisors of a number ≤K. What can be said about number containing s distinct prime divisors?:
		<center>(I) If x can be shown as 

			{% macro paritial(value) -%}
				<msub><mi>p</mi><mi>{{value}}</mi></msub>
			{% endmacro %}

			{% macro supasub(value) -%}
				<msup>
					<mrow>
						<msub><mi>p</mi><mi>{{value}}</mi></msub>
					</mrow>
					<mrow>	
						<msub><mi>a</mi><mi>{{value}}</mi></msub>
					</mrow>
				</msup>
			{%- endmacro %}
				
			

			<math>
				<mi>x</mi><mo>=</mo>
				{% for j in range(2) %}
					{{supasub(j)}}<mo>*</mo>
				{% endfor %}
				...<mo>*</mo>{{supasub("n")}}
			</math>
			then there is y≤K that can be shown as 
			
			<math>
				<mi>y</mi><mo>=</mo>
				{% for j in range(2) %}
					{{paritial(j)}}<mo>*</mo>
				{% endfor %}
				...<mo>*</mo>{{paritial("n")}}
			</math>
			having same number of distinct prime divisors.
		</center>

		<center>(II) If there if such prime number v such that <mi>v</mi>&lt;p<sub>i</sub>, then there exists such z that
			<math>
				<mi>z</mi>=<mfrac>
					<mrow>y</mrow>
					<mrow><msub><mi>p</mi><mi>i</mi></msub></mrow>
				</mfrac>
				<mo>*</mo>v<mo>≤</mo>K
			</math>
		</center>
		What follows, one can construct number with highest numbers of prime divisors and lower or equal to K by multiplying subsequent prime numbers, starting from lowest: 2*3*5*...*p<sub>m</sub>; m≤log2(n), and the proof is finished giving better approximation of number of used steps in this algorithm.

		</div>	
		<br>

		<div id="gutSieve">
			Query answering can be done in O(q), because for each query {{msub("a","i")}} one only needs to look whether it is marked as prime or not - that can be done in O(1). So total complexity for a given task is at most O(n*log2(n)+q), where n is number, for which we run sieve, that is <math>n≤max({{msub("a","i")}})</math>. However, this sieve can be used to much more sophisticated tasks: let's Say you have same task, but instead of determining whether number is prime, You have to factorize it, i.e. find it's representation as product of prime numbers. Such representation is unique for each number. If you'll mark each number with it's lowest divisor (instead of sole information whether it's prime) then You'll be able to solve this problem in the same way as above, in complexity O(nlog2(n)+qlog2(n)): below is an animation of inner workings of such sieve and query mechanism (which works only after finishing sieve)
		</div>

	</div>
	
	<br><br>
	<div id="Algo2">
		<div id="sieveSection">
			<h2 style="left:35%;">Enchanced Sieve</h2>
			<div id="Inputter2">
				<form>
					<input type="number" id="Erasto2" class="inputter" name="Erasto2" value="99">
				</form>
				<button id="Sender2" class="sender">Begin</button>
				<button id="Prever2" class="previous">Previous Move</button>
				<button id="Nexter2" class="next">Next Move</button>
				<button id="Finisher2" class="finish">Finish</button>
			</div>
			<div class="breakAlgo"></div>
			<div id="Primez2" class="primez"></div>
			<div id="Comprehend2" class="comprehend"></div>
		</div>


		<div id="querySection">
			<h2 style="left:35%;">Factorization query</h2>
			<div id="Inputter3">
				<form>
					<input type="number" id="Querier" class="inputter" name="query" value="99">
				</form>
				<button id="Sender3" class="sender">Begin</button>
				<button id="Prever3" class="previous">Previous Move</button>
				<button id="Nexter3" class="next">Next Move</button>
				<button id="Finisher3" class="finish">Finish</button>
			</div>
			<div class="breakAlgo"></div>
			<div class="primez"></div>
			<div id="Query_output" class="comprehend">
				PenisHahah!
			</div>
		</div>
	</div>

	<div id="debug"></div>
	<script src={{url_for('static', filename='Primes.js')}}></script>
</body>
