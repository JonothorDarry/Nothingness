<!DOCTYPE html>
{% macro mt(a) -%}
	<math><mi>{{a}}</mi></math>
{%- endmacro %}

{% macro msub(math=1, a="a", b="i") -%}
	{% if(math==1) %}
		<math>
	{% endif %}
	<msub>
		<mrow>{{a}}</mrow>
		<mrow>{{b}}</mrow>
	</msub>
	{% if(math==1) %}
		</math>
	{% endif %}
{%- endmacro %}

{% macro msup(a, b, math=1) -%}
	{% if(math==1) %}
		<math>
	{% endif %}
		<msup>
			<mrow>{{a}}</mrow>
			<mrow>{{b}}</mrow>
		</msup>
	{% if(math==1) %}
		</math>
	{% endif %}
{%- endmacro %}

{% macro mopera(math, a, op, b) -%}
	{% if(math==1) %}
		<math>
	{% endif %}
	<mi>{{a}}</mi>
	<mo>{{op}}</mo>
	<mi>{{b}}</mi>
	{% for x in varargs %}		
		{% if(loop.index%2==1) %}
			<mo>{{x}}</mo>
		{% else %}
			<mi>{{x}}</mi>
		{% endif %}
	{% endfor %}

	{% if(math==1) %}
		</math>
	{% endif %}
	
{%- endmacro %}

{% macro mfrac(a, b, math=1) -%}
	{% if(math==1) %}
		<math>
	{% endif %}
		<mfrac>
			<mrow>{{a}}</mrow>
			<mrow>{{b}}</mrow>
		</mfrac>
	{% if(math==1) %}
		</math>
	{% endif %}
{%- endmacro %}

<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" href={{url_for('static', filename='Primes.css')}}>
</head>
<body>
	<h1>Greatest Common Divisor</h1>
	<h3>First problem statement and definitions</h1>
	<div>
		Let's say <math>q (q&lt;1000000)</math> queries are given: what is the greatest common divisor of numbers {{mt("u")}} and {{mt("v")}} where <math>{{mt("u")}}, {{mt("v")}}&lt;1000.000.000</math>? To answer this question, let's define greatest common divisor (gcd): A number {{mt("g")}} is gcd of numbers {{mt("u")}}, {{mt("v")}} if and only if:<br>
		<center>
			<math>{{mt("g")}}=gcd({{mt("u")}},{{mt("v")}}) ⇔ {{mt("g")}}|{{mt("u")}} ∧ {{mt("g")}}|{{mt("v")}} ∧ {{msub(0,"!∃","h")}}({{mt("h")}}|{{mt("u")}} ∧ {{mt("h")}}|{{mt("v")}} ∧ {{mopera(0,"h",">","g")}})</math>
		</center><br>
		In other words, if <math>{{mt("g")}}=gcd({{mt("u")}}, {{mt("v")}})</math>, then {{mt("g")}} divides {{mt("u")}} and {{mt("v")}}, and there is no greater number {{mt("h")}} that divides both {{mt("u")}} and {{mt("v")}}. First solution not being absolute brute force (checking all numbers <math>x∈&lt;2;min({{mt("u")}},{{mt("v")}})&gt;</math> whether they're gcd - works in <math>O(q*min({{mt("u")}},{{mt("v")}})</math>) is discussed below:
	</div>
	<h3>First solution</h3>
	<div>
		Without loss of generality, let's assume that {{mopera(1,"u","<","v")}}. One can check all positive natural numbers {{mopera(1,"k","<","u")}} whether {{mopera(1,"k","|","u")}} and {{mopera(1,"k","|","v")}}, and take largest such number. To find all divisors of {{mt("u")}}, one can check all numbers {{mt("k")}} lower than <math><msqrt><mi>u</mi></msqrt></math> if they divide both of them, and their counterparts - {{mfrac("u","k")}} - this will work in O(<math><mi>q</mi>*<msqrt><mi>u</mi></msqrt></math>).
	</div>
	<h3>Second Solution</h3>
	<div>
		Let's create arrays {{msub(1)}} and {{msub(1,"b")}} such that {{mopera(1,msub(1,"a",0), "=", "u")}}, {{mopera(1,msub(1,"b",0), "=", "v")}}. One can define these arrays for {{mopera(1,"i",">",0)}} as {{mopera(1,msub(1,"a","i"),"=",msub(1,"b","i-1"))}} and {{mopera(1,msub(1,"b","i"),"=",mopera(1, msub(1,"a","i-1"), "mod", msub(1,"b","i-1")))}}. When {{mopera(1,msub(1,"b","i"),"=",0)}} then {{msub(1,"a","i")}} is the solution.

	</div>
	<div id="Algo1">
		<h2>Euclidean algorithm</h2>
		<div id="Inputter">
			<form>
				<input class="inputter" id="Erasto" name="Erasto" value="84 35">
			</form>
			<button id="Sender" class="sender">Begin</button>
			<button id="Prever" class="previous">Previous Move</button>
			<button id="Nexter" class="next">Next Move</button>
			<button id="Finisher" class="finish">Finish</button>
		</div>
		<div class="breakAlgo"></div>
		<div id="Primez" class="primez"></div>
		<div id="Comprehend" class="comprehend"></div>
	</div>
	<div id="debug"></div>

	<h2>Proofs</h2>
	<h3>Finiteness proof</h3>
	<div>
		In each iteration, {{msub(1,"b","i")}} becomes {{mopera(1,msub(1,"a","i-1"),"mod",msub(1,"b","i-1"))}}, but <math>{{mopera(1,msub(1,"a","i-1"),"mod",msub(1,"b","i-1"))}}&lt;{{msub(0,"b","i-1")}}</math> by definition - and so, in each iteration {{msub(1,"b","i")}} becomes lower, but in each iteration it's greater than 0 or algorithm ends - so number of steps must be lower or equal to {{msub(1,"b","i")}} at the beginning of the algorithm, so it is finite
	</div>
	<h3>Correctness proof</h3>
	<div>
		Thesis: for each {{mt("i")}}, gcd({{msub(1,"a","i")}}, {{msub(1,"b","i")}}) is equal to gcd({{mt("u")}}, {{mt("v")}}).<br>
		Proof by induction: For {{mopera(1,"i","=",0)}} gcd({{msub(1,"a",0)}}, {{msub(1,"b",0)}})=gcd({{mt("u")}}, {{mt("v")}}), because {{msub(1,"a",0)}}={{mt("u")}}, {{msub(1,"b",0)}}={{mt("v")}}. So: {{msub(1,"∃","i")}} gcd({{msub(1,"a","i")}}, {{msub(1,"b","i")}})=gcd({{mt("u")}}, {{mt("v")}}). To finish proof is to show that for any {{mt("i")}} either gcd({{msub(1,"a","i")}}, {{msub(1,"b","i")}})=gcd({{msub(1,"a","i+1")}}, {{msub(1,"b","i+1")}}) or {{mopera(1,msub(1,"b","i+1"),"=",0)}}<br>	
		What can be said about any divisor {{mt("g")}} dividing both {{msub(1,"a","i")}} and {{msub(1,"b","i")}}? If {{msub(1,"a","i")}} is shown as {{mopera(1,"s","*",msub(1,"b","i"),"+","m")}}, where {{mt("s")}}∈{{mt("N")}}, then:
		
		<br><center>{{mopera(1,msub(1,"a","i"),"=","g","*","k")}}, {{mopera(1,msub(1,"b","i"),"=","g","*","l")}}, {{mopera(1,msub(1,"a","i"),"=","s","*",msub(1,"b","i"),"+","m")}}</center><br>
		<center>{{mopera(1,"g","*","k","=","s","*","g","*","l","+","m")}}</center><br>
		<center>{{mopera(1,"g","*","k","-","s","*","g","*","l","=","g","*(","k","-","s","*","l",")=","m")}}</center><br>
		and so, any common divisor {{mt("g")}} dividing both {{msub(1,"a","i")}}, {{msub(1,"b","i")}} has to divide {{mopera(1,msub(1,"a","i"),"mod",msub(1,"b","i"))}} - and so, gcd({{msub(1,"a","i")}}, {{msub(1,"b","i")}})=gcd({{mopera(1,msub(1,"a","i"),"mod",msub(1,"b","i"))}}, {{msub(1,"b","i")}})=gcd({{msub(1,"b","i")}}, {{mopera(1,msub(1,"a","i"),"mod",msub(1,"b","i"))}})=gcd({{msub(1,"a","i+1")}}, {{msub(1,"b","i+1")}}). If {{msub(1,"b","i")}} becomes equal to 0, then any number divides 0, and so any number that is divisor of both {{mt("u")}} and {{mt("v")}} must divide {{msub(1,"a","i")}}. The only thing left to do is finding greatest divisor of a number {{mopera(1,msub(1,"a","i"),">",0)}} - which is equal to {{msub(1,"a","i")}}, which finishes the proof.

	</div>
	<h3>Complexity proof</h3>
	<div>
		It can be assumed without loss of generality, that {{mopera(1,msub(1),">",msub(1,"b"))}} - it is true after first iteration. Furthermore, 
		<br><center>{{mopera(1,msub(1,"b","i"),"+",msub(1,"a","i"),"mod",msub(1,"b","i"),"<",msub(1,"b","i"),"+",msub(1,"b","i"),"=",2,"*",msub(1,"b","i"))}}</center><br>
		To prove that {{mfrac(mopera(1,msub(1,),"+",msub(1,"b",)), mopera(1,msub(1,"a","i+1"),"+",msub(1,"b","i+1")), 1)}}&ge;{{mfrac("3","2")}} , let's consider two cases: first, when {{mopera(1,msub(1,"a","i+1"),"≥","2","*",msub(1,"b","i+1"))}}, second, when {{mopera(1,2,"*",msub(1,"b","i+1"),">",msub(1,"a","i+1"),"≥",msub(1,"b","i+1"))}}.

		<br><center>(1) <math>{{mfrac(mopera(1,msub(1),"+",msub(1,"b")),mopera(1,msub(1,"a","i+1"),"+",msub(1,"b","i+1")),0)}}={{mfrac(mopera(1,msub(1),"+",msub(1,"b")),mopera(1,msub(1),"mod",msub(1,"b"),"+",msub(1,"b")),0)}}&ge;{{mfrac(mopera(1,msub(1),"+",msub(1,"b")),mopera(1,2,"*",msub(1,"b")),0)}}&ge;{{mfrac(mopera(1,2,"*",msub(1,"b"),"+",msub(1,"b")),mopera(1,2,"*",msub(1,"b")),0)}}={{mfrac(mopera(1,3,"*",msub(1,"b")),mopera(1,2,"*",msub(1,"b")),0)}}={{mfrac("3","2",0)}}</math></center>

		<br><center>(2) <math>{{mfrac(mopera(1,msub(1),"+",msub(1,"b")),mopera(1,msub(1,"a","i+1"),"+",msub(1,"b","i+1")),0)}}={{mfrac(mopera(1,msub(1),"+",msub(1,"b")),mopera(1,msub(1),"mod",msub(1,"b"),"+",msub(1,"b")),0)}}
		={{mfrac(mopera(1,msub(1),"+",msub(1,"b")),mopera(1,msub(1),"-",msub(1,"b"),"+",msub(1,"b")),0)}}
		={{mfrac(mopera(1,msub(1),"+",msub(1,"b")),msub(1),0)}}
		={{mopera(1,1,"+",mfrac(msub(1,"b"),msub(1),1))}}
		&ge;{{mopera(1,1,"+",mfrac(msub(1,"b"),mopera(1,2,"*",msub(1,"b")),1))}}
		={{mfrac("3","2",0)}}</math></center><br>
	And so, maximum number of operations can be bounded by O(q*log(min({{mt("u")}}, {{mt("v")}}))), because sum {{mopera(1,msub(1),"+",msub(1,"b"))}} is always greater than 0, and after kth iteration it becomes lower at least {{msup("("+mfrac(3,2,0)+")","k",1)}} times.
	</div>
	<h3>Second Problem</h3>
	<div>
		Let's say that sole gcd({{mt("u")}},{{mt("v")}}) is not enough: You want to find such numbers {{mt("x")}}, {{mt("y")}}, such that for each {{mt("i")}} {{mopera(1,"u","*","x","+","v","*","y","=")}}gcd({{mt("u")}},{{mt("v")}}). One can use same mechanism to solve this problem, but calculate also arrays p, q, such that {{mopera(1,msub(1,"p","i"),"*","u","+",msub(1,"q","i"),"*","v","=",msub(1,"b"))}}. {{mopera(1,msub(1,"p",1),"=",0)}}, {{mopera(1,msub(1,"q",1),"=",1)}} because {{mopera(1,"u","*",msub(1,"p",1),"+","v","*",msub(1,"q",1),"=","v")}}. Then, if z=floor(a/b), then {{msub(1,"b","i")}}={{msub(1,"a","i-1")}}-b'*z=(p[i-2]+q[i-2])-z*(p[i-1]+q[i-1]). And so, p[i]=p[i-2]-p[i-1]*z, q[i]=q[i-2]-z*q[i-1]. Animation shows, what is unseen.
	</div>

	<div id="Algo2">
		<h2>Extended Euclidean Algorithm</h2>
		<div id="Inputter2">
			<form>
				<input class="inputter" id="Erasto2" name="Erasto" value="84 35">
			</form>
			<button id="Sender2" class="sender">Begin</button>
			<button id="Prever2" class="previous">Previous Move</button>
			<button id="Nexter2" class="next">Next Move</button>
			<button id="Finisher2" class="finish">Finish</button>
		</div>
		<div class="breakAlgo"></div>
		<div id="Primez2" class="primez"></div>
		<div id="Comprehend2" class="comprehend"></div>
	</div>
	
	<script src={{url_for('static', filename='Gcd.js')}}></script>
</body>
