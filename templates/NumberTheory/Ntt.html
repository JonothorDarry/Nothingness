<!DOCTYPE html>
{% import 'headers.html' as headers %}

<html lang="en">
	<head>
		<title>Number Theoretic Transform</title>
		<meta charset = "UTF-8">
		<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='Temp.css')}}">
		<script src="{{url_for('static', filename='Temp.js')}}"></script>
		<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
	</head>

	<body>
		{{ headers.header('Number Theoretic Transform', 'NumberTheory') }}
		<h3>First problem statement and definitions</h3>
		<p>Suppose You are given coefficients \(a_0, a_1, \dots, a_o\) and \(b_0, b_1, \dots, b_m\) of two polynominals \(A(x), B(x)\), \(1 \le o,m,a_i,b_i \le 10^5\), and Your aim is to multiply them; in other words, You have to find such sequence \(c_0, c_1, \dots, c_{o+m}\) such that \(A(x)B(x)=(a_0+a_1x+a_2x^2+\dots+a_ox^o)(b_0+b_1x+b_2x^2+\dots+b_mx^m)=(c_0+c_1x+c_2x^2+\dots+c_{m+o}x^{m+o})=C(x)\). This problem can be solved in at least \(2\) versions: when You have to calculate coefficients as they are, or \(\pmod x\), where \(x\) has a primitive root and \(\exists_k 2^k|\phi(x) \land 2^k \gt m+o\) and \(2 \nmid x\)</p>
		<h3>First solution</h3>
		<p>One can multiply each element in the first bracket with element from second bracket, then add resulting \(om\) elements; this solution works in \(O(om)\)
		<h3>Threshold of transformation</h3>
		<ol>
			<li>If \(m+o=k\), then let \(n\) be minimal number, such that \(n \gt k \land \exists_{l \in Z} n=2^l\). Then, the result will be calculated as \(n\) coefficients, and polynominals \(A(x), B(x)\) will be used as if they had \(n\) coefficients (The additional coefficients, say, for \(A(x)\) they will be \(a_{o+1}, a_{o+2} \dots a_{n-1}\) will be evaluated to \(0\))</li>
			<li>One may change the methodology of obtaining a polynominal a little bit: instead of directly finding the coefficients of \(C(x)\), one may find \(n\) values \(x_i\), obtain values of both \(A(x_i)\) and \(B(x_i)\) in those points, then multiply values \(A(x_i)B(x_i)=C(x_i)=y_i\), and transform \(n\) values of polynominal \(C(x)\) in points \(x_i: C(x_i)=y_i\) into its coefficients - this process is called interpolation of a polynominal.</li>
			<li>Let 
				<span class="central">\(A(x)=a_0+a_1x+ \dots + a_{n-1}x^{n-1}\)<br>
					\(A_1(x)=a_1+a_3x+a_5x^2+ \dots a_{n-1}x^{n/2-1}\)<br>
					\(A_0(x)=a_0+a_2x+a_4x^2+ \dots a_{n-2}x^{n/2-1}\)
				</span>
				What follows, 
				<span class="central">\(A(x)=A_0(x^2)+xA_1(x^2)\)</span>
				What follows, one can calculate recursively values of polynominals \(A_0\),\(A_1\), then find the value of \(A(x)\) - the process will take \(O(nlog(n))\), if one problem will be addressed -Â if \(A_0(x_i)\) was found, then the places, in which \(A(x)\) an be easily calculated are \(A(x_i^{1/2})\) and \(A(-x_i^{1/2})\) - so one needs to find suitable points for evaluating polynominal for subsequent iterations. </li><br>
			<li>Let \(w_n^k=f^{\frac{kg}{n}}\), where \(f^g\) is some predefined value. Then, if in \(i\)-th iteration one uses values \(w_{n/2}^0, w_{n/2}^1, \dots, w_{n/2}^{n/2}\), in next iteration one can use values \(w_n^0, w_n^1, \dots, w_n^{n/2}\) without any problems as next places, in which value of polynominal will be calculated. Furthermore, \(w_n^{s+n/2}=w_n^{n/2}w_n^s\), where \(s \le \frac{n}{2}\); <b>this leads to establish \(w_n^{n/2}=-1\), and \(f^g=w_n^n=1\);</b> then, \(w_n^{s+n/2}=w_n^{n/2}w_n^s=-w_n^s\), and \(w_n^{2(s+n/2)}=w_n^nw_n^{2s}=1w_{n/2}^s\) - so, one can calculate easily values of polynominal \(A(x)\) in \(n\) points if values of \(A_0(x), A_1(x)\) in certain \(\frac{n}{2}\) points were calculated. All roots \(w_n^k\) have to be different, otherwise the last part of the algorithm will not work (because many polynominals of degree \( \le n\) can have same values in \(\le n\) points and the result would be ambiguous).</li><br>

			<li>It may be beneficial to get rid of recursion before things start getting messy; to find value of \(A(x)\) in \(n\) points, one needs to find values of \(A_0(x)=a_0+a_2x+\dots+a_{n-2}x^{n/2-1}\) and \(A_1(x)=a_1+a_3x+\dots+a_{n-1}x^{n/2-1}\) in \(\frac{n}{2}\) points. Then, to find values of \(A_0(x)\) one needs to find values of \(a_0+a_4x+a_8x^2+\dots+a_{n-4}x^{n/4}\) and \(a_2+a_6x+a_{10}x^2+\dots+a_{n-2}x^{n/4}\) in \(\frac{n}{4}\) points, etc.<br><br>

				One can generalize the notion of polynominal on each level of recursion: if \(n=2^k\), then let \(A_{k,0}(x)\) be the polynominal given at the start; then, one can define \(A_{lev,pol}\) as \(pol\)-th polynominal calculated on \(lev\)-th level of recursion. \(A_{lev,pol}(x)=A_{lev-1,2pol}(x^2)+xA_{lev-1,2pol+1}(x^2)\) - the \(2pol\) and \(2pol+1\) emerge from fact, that every previous polynominal on the same level has exactly 2 polynominals on lower level. There will be \(k\) levels of recursion, on \(lev\)-th each level polynominal consists of \(2^{lev}\) coefficients (perhaps with leading 0's) - on lowest level of recursion it will consist of one coefficient, so its value is constant, equal to this coefficient.<br><br>
				
				For example, for \(n=16\), the subsequent coefficients of polynominals in recursion will be:
				{% set pows=[1, 2, 4, 8, 16] %}
				{% set ns = namespace(start=0, broke=1) %}
				{% for cur in range(0, 5) %}
					{% set x=pows[cur] %}
					<span class="central">\(
					{% set ns.start=0 %}
					{% for i in range(0, x) %}
						{% set y=(16//x) %}
						(
						{% for j in range(0, y) %}
							a_{ {{j*x+ns.start}} }
							{% if j!=y-1 %}
								,
							{% endif %}
						{% endfor %}

						{% set ns.broke=1 %}
						{% for j in range(cur-1, -1, -1) %}
							{% if ns.start>=pows[j] and ns.broke==1 %}
								{% set ns.start=ns.start-pows[j] %}
							{% elif ns.broke==1 %}
								{% set ns.start=ns.start+pows[j] %}
								{% set ns.broke=0 %}
							{% endif %}
						{% endfor %}
						)
					{% endfor %}
					\)</span>
				{% endfor %}
				But only on the lowest level of recursion those coefficients are useful; in higher levels of recursion finding values of a polynominal in a point - is only dependant on that point and previous values of polynominals: \(A_{lev,pol}(x)=A_{lev-1,2pol}(x^2)+xA_{lev-1,2pol+1}(x^2)\). On a lowest level, value of a polynominal in form \(A_{0,pol}(x)=a_i\) is the coefficient itself; the question arises, how to construct such sequence as in the lowest level of recursion? This allows to process subsequent polynominals as pair of two next polynominals from level below. One can observe, that:
				<ul>
					<li>In a group there are subsequent numbers with same difference between them: At the start, there is one group with difference \(1\); in each partition, a group is divided into two groups with every second element each; as the difference is constant between each - say \(d\), then in group on lower level there will be subsequent numbers with difference \(2d\). Furhermore, difference within one group is equal to \(2^l\), as on the highest level difference is \(1\), and in each lower level the difference becomes twice higher.</li>
					<li>As in each group \(g_0\) there are subsequent elements with difference \(d\), then after division into groups \(g_1\) and \(g_2\) difference between \(k\)-th element of \(g_2\) and \(g_1\) is equal to \(d=2^{l-1}\), as subsequent elements from \(g_0\) go to different groups. Furthermore, both groups since then are divided in same way - then this holds after subsequent division and going deeper into recursion (that \(g_2(k)-g_1(k)=2^{l-1}\)).</li>
				</ul>
				So, one can create such algorithm for attaining subsequent numbers in this seqence, call it \(S\) with element \(S(i)\): at the beginning, \(S(0)=0\), then, whenever \(2^x\) for some \(x\) is reached, then all subsequent elements up to \(2^{x+1}-1\) are evaluated as \(S(i)=S(i-2^x)+2^{k-x-1}\), where \(2^{k}=n\); the \(2^{k-x-1}\) follows from fact, that \(k-x-1\) is nember of splits into \(2\) groups before this one.
			</li>
			<li>After finding salvation from abyss of abstract, absolutely brutal and unforgiving realm of finding values of two polynominals in \(n\) points in \(O(nlog(n))\), it may be wise to multiply values of both polynominals in those points: \(C(x_i)=A(x_i)B(x_i)\) this step works in \(O(n)\)</li>
			<li>The final problem is finding from values \(C(x_0), C(x_1), \dots C(x_n)\) coefficients \(c_0, c_1, \dots, c_{n-1}\) of a polynominal \(C(x)\). One can represent the problem as matrix equation:
			<span class="central">
			$$
			\begin{bmatrix}
				w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0\\
				w_n^0 & w_n^1 & w_n^2 & \cdots & w_n^{n-1}\\
				w_n^0 & w_n^2 & w_n^4 & \cdots & w_n^{2(n-1)}\\
				w_n^0 & w_n^3 & w_n^6 & \cdots & w_n^{3(n-1)}\\
				\vdots & \vdots & \vdots & \ddots & \vdots\\
				w_n^{0} & w_n^{n-1} & w_n^{2(n-1)} & \cdots & w_n^{(n-1)(n-1)}\\
			\end{bmatrix}
			\begin{bmatrix}
			c_0 \\ c_1 \\ c_2 \\ c_3 \\ \vdots \\  c_{n-1} \\
			\end{bmatrix}
			=
			\begin{bmatrix}
			y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\  y_{n-1} \\
			\end{bmatrix}

			$$
			</span>
			<span class="central">
			$$

			\begin{bmatrix}
			c_0 \\ c_1 \\ c_2 \\ c_3 \\ \vdots \\  c_{n-1} \\
			\end{bmatrix}
			=
			\begin{bmatrix}
				w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0\\
				w_n^0 & w_n^1 & w_n^2 & \cdots & w_n^{n-1}\\
				w_n^0 & w_n^2 & w_n^4 & \cdots & w_n^{2(n-1)}\\
				w_n^0 & w_n^3 & w_n^6 & \cdots & w_n^{3(n-1)}\\
				\vdots & \vdots & \vdots & \ddots & \vdots\\
				w_n^{0} & w_n^{n-1} & w_n^{2(n-1)} & \cdots & w_n^{(n-1)(n-1)}\\
			\end{bmatrix}^{-1}
			\begin{bmatrix}
			y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\  y_{n-1} \\
			\end{bmatrix}
			$$
			</span>
			So, to solve given problem, one can find certain inverse matrix - if one exists, then there is only one. One can show, that:
			<span class="central">
			$$
			A^{-1}=
			\begin{bmatrix}
				w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0\\
				w_n^0 & w_n^1 & w_n^2 & \cdots & w_n^{n-1}\\
				w_n^0 & w_n^2 & w_n^4 & \cdots & w_n^{2(n-1)}\\
				w_n^0 & w_n^3 & w_n^6 & \cdots & w_n^{3(n-1)}\\
				\vdots & \vdots & \vdots & \ddots & \vdots\\
				w_n^{0} & w_n^{n-1} & w_n^{2(n-1)} & \cdots & w_n^{(n-1)(n-1)}\\
			\end{bmatrix}^{-1}
			=
			\frac{1}{n}
			\begin{bmatrix}
				w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0\\
				w_n^0 & w_n^{-1} & w_n^{-2} & \cdots & w_n^{-(n-1)}\\
				w_n^0 & w_n^{-2} & w_n^{-4} & \cdots & w_n^{-2(n-1)}\\
				w_n^0 & w_n^{-3} & w_n^{-6} & \cdots & w_n^{-3(n-1)}\\
				\vdots & \vdots & \vdots & \ddots & \vdots\\
				w_n^{0} & w_n^{-(n-1)} & w_n^{-2(n-1)} & \cdots & w_n^{-(n-1)(n-1)}\\
			\end{bmatrix}
			=
			B
			$$
			</span>
			This equality stems from several theses (where \(AB=M\)):
			<ul>
				<li>The value of \(M[i,j]\) will be equal to 
					<span class="central">\(M[i,j]=\frac{1}{n}(A[i,0]B[0,j]+A[i,1]B[1,j]+A[i,2]B[2,j]+ \dots + A[i,n-1]B[n-1,j])=\frac{1}{n}(w_n^0w_n^0+w_n^iw_n^{-j}+w_n^{2i}w_n^{-2j}+ \dots +w_n^{(n-1)i}w_n^{-(n-1)j})=\)</span><span class="central">\(=\frac{1}{n}(w_n^{0(i-j)}+w_n^{1(i-j)}+w_n^{2(i-j)}+ \dots +w_n^{(n-1)(i-j)})=\frac{1}{n}\sum_{k=0}^{n-1}w_n^{k(i-j)}\)</span>
				</li>
				<li>Let \(c=i-j\); as \(\forall_{x \in Z} w_n^x=1 \iff x \equiv 0 \pmod n\) (this emerges from fact, that all roots have to be different - and this shows, why <b> roots have to be different</b>), then what can be said about \(s: w_n^{sc}=1\)? Clearly, \(sc=h*lcm(n, c)=h\frac{nc}{gcd(n, c)}\) for some natural \(h\). A minimal \(s \gt 0\) is \(s=\frac{n}{gcd(n, c)}\). Certainly, \(s|n\) - and so, \(s=2^f\) for some natural \(f\). Furthermore, \(s=1\) if and only if \(gcd(n, c)=n\).
				</li>
				<li>What can be said about \(c\)? as \(-n \lt i-j=c \lt n\), then \(gcd(n, c)=n \iff i-j=c=0\). In this case, 
					<span class="central">$$\frac{1}{n}\sum_{k=0}^{n-1}w_n^{k(i-j)}=\frac{1}{n}\sum_{k=0}^{n-1}w_n^0=\frac{1}{n}\sum_{k=0}^{n-1}1=\frac{1}{n}n=1$$</span> - this is the value of the main diagonal \(M[i,i]\) of resulting matrix.</li>
				<li>If \(c \neq 0\), then \(w_n^{cs/2}=-1\) - because \(2|s\) and \(w_n^{cs/2} \neq 1\) (by definition of \(s\)). In this case:
					{% set beg="\\frac{1}{n}\sum_{k=0}^{n/s-1}"%}
					<span class="central">$$M[i,j]=\frac{1}{n}\sum_{k=0}^{n-1}w_n^{(i-j)k}={{beg}} \sum_{l=0}^{s-1}w_n^{c(ks+l)}={{beg}} \sum_{l=0}^{s-1}(w_n^{cs})^{k}w_n^{cl}={{beg}} \sum_{l=0}^{s-1}w_n^{cl}={{beg}} \sum_{l=0}^{s-1}w_n^{cl}={{beg}} \sum_{l=0}^{s/2-1}w_n^{cl}+w_n^{s/2+cl}={{beg}} \sum_{l=0}^{s/2-1}w_n^{cl}-w_n^{cl}={{beg}} \sum_{l=0}^{s/2-1}0=0$$</span>
				</li>
			</ul>
			And so, M is indeed identity matrix, so \(B=A^{-1}\)
			</li>
			<li>
				From inverse matrix equation, one may notice, that to calculate \(c_i\) is to solve following equation:
				<span class="central">$$c_i=\frac{1}{n} \sum_{j=0}^{n-1}y_jw_n^{-ij}$$</span>
				First of all, \(w_n^{-i}w_n^{i}=1=w_n^n=w_n^iw_n^{n-i}\). If \(w_n^{i}\) has exactly one inverse, then \(w_n^{n-i}=w_n^{-i}\). Secondly, the values calculated in the first phase of the algorithm had form:
				<span class="central">$$y_i=\sum_{j=0}^{n-1}a_iw_n^{ij}$$</span>
				The only differences are: lack of division by \(n\), and \(w_n^{ij}\) instead of \(w_n^{-ij}\) - this allows one to construct algorithm finding \(c_i\) in \(O(nlog(n))\) in the same way as for finding \(y_i\).
			</li>
		</ol>

		<h3>The conditions on roots and \(n\) for subsequent algorithms</h3>
		<p>The rules below concern: when is it possible to proceed with transformation as described above?</p>
		<ol>
			<li>\(n\) must have an inverse.</li>
			<li>\(w_n^n=1\)</li>
			<li>\(w_n^{n/2}=-1\)</li>
			<li>There must exist at least \(n\) distinct roots of unity: \(w_n^i \neq w_n^j\) for \((i \neq j) \land (0 \le i,j \lt n)\).</li>

		</ol>

		<h3>The sequence of roots I: NTT</h3>
		<p>Last question needed to ultimately solve the problem is: what is \(w_n^1\)? In the second version of the problem, the coefficients have to be calculated \(\pmod m\). If \(m\) have a primitive root \(p\), then:</p>
		<ol>
			<li>One can find some primitive root \(p\) rather rapidly.</li>
			<li>If \(p\) is a primitive root, then \(p^{\phi(m)/2}=m-1\) - that's because:
				<ul>
					<li>\(m-1\) is coprime to \(m\) - so, there exists exponent \(g\) such that \(p^g=m-1\).</li>
					<li>\((m-1)^2=m^2-2m+1 \equiv 1 \pmod m\).</li>
					<li>For any \(g \neq \frac{\phi(m)}{2} \land g \neq \phi(m)\) occurs: \(p^{2g}\) is not equivalent to \(1 \pmod m\) - so only possible exponent \(g\), such that \((m-1) \equiv p^g \pmod m\) is \(\frac{\phi(m)}{2}\).</li>
				</ul>
			</li>
			<li>One can notice, that if \(\phi(m)=2^kx\), then \(w_n^1=p^{x2^{k-n}}=p^{\phi(m)/2^n}\) can be used as a root - because, as \(p\) is a primitive root, values \(w_n^k\) will be distinct; becuse \(w_n^{n/2}=m-1\), and \(w_n^n=1\).</li>
			<li>Note, that \(m\) does not have to have a primitive root, however, in this case one needs to find such number \(g\), whose \(ord_m(g)=2^kx\), where \(k \ge n\) - and such number may not exist, finding it can also become problematic. Furthermore, \(w_n^{n/2}\) does not necessarily need to be equal to \(p-1\)</li>
			<li>Furthermore, \(n\) must have an inverse \(\pmod m\) - as \(n=2^k\), then \(gcd(2, m)=1\)</li>
		</ol>

		<h3>The sequence of roots II: FFT</h3>
		<p>In the first version of the problem, the coefficients are calculated as they are. Instead of finding primitive root, Euler's identity: \(e^{2\pi x}=cos(x)+i*sin(x)\) is used, and calculations are executed using complex numbers.</p>
		<ol>
			<li>\(\frac{1}{n}\) has an inverse in real numbers (then also in complex numbers).</li>
			<li>Let \(w_n^k=e^{2\pi k/n}\) - then \(w_n^n=e^{2 \pi n/n}=e^{2 \pi}=cos(2\pi)+i*sin(2\pi)=1+i*0=1\)</li>
			<li>\(w_n^{n/2}=e^{2\pi n/(2n)}=e^{\pi}=cos(\pi)+i*sin(\pi)=-1+i*0=-1\)</li>
			<li>The roots \(w_n^k\) are distinct, because:
			<ul>
				<li>Functions \(sin(x)\) and \(cos(x)\) have different pair of signs in each quarter - so if \(x \neq y \land sin(x)=sin(y) \land cos(x)=cos(y)\), then they must lie in the same quarter.</li>
				<li>Functions \(sin(x)\) and \(cos(x)\) are monotonically increasing/decreasing in single quarter - so if \(x \neq y \land sin(x)=sin(y) \land cos(x)=cos(y)\), then they must lie in different quarters</li>
				<li>For \(sin(x)\) and \(cos(x)\) in points \(0, \frac{\pi}{2}, \pi, \frac{3\pi}{2}\) one can check property himself.</li>
			</ul>
			</li>
		</ol>

		<div id="Algo1" class="pureAlgo">
			<h2>Number Theoretic Transform</h2>
			<p>Input format: two sequences of \(o+1, m+1\) numbers denoting coefficients of polynominals \(A(x), B(x)\); then, \(q\) - number modulo which those coefficients will be found.<br>
			\(o\)<br>
			\(a_0, a_1, \dots, a_o\)<br>
			\(m\)<br>
			\(b_0, b_1, \dots, b_m\)<br>
			\(q\)<br>
			</p>

			<div id="Inputter">
				<form>
					<textarea class="inputter" id="Totient2" name="Totient">6&#10;2 7 3 12 43 25 19&#10;7&#10;4 6 7 1 2 3 4 132&#10;257
					</textarea>
				</form>
			</div>
			<div id="Buttons" style="position:sticky; top:0; z-index:1;">
				<button id="Sender" class="sender">Begin</button>
				<button id="Prever" class="previous">Previous Move</button>
				<button id="Nexter" class="next">Next Move</button>
				<button id="Finisher" class="finish">Finish</button>
			</div>

			<div class="breakAlgo"></div>
			<div id="Primez" class="primez"></div>
			<div id="Comprehend" class="comprehend" style="background-color:#FFFFAA; position:sticky; bottom:0; z-index:1;"></div>
		</div>

		<script src="{{url_for('static', filename='Ntt.js')}}"></script>
		<form id="page" style="display:none"></form>
	</body>
</html>
