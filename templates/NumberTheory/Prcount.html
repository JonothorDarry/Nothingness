<!DOCTYPE html>
{% import 'headers.html' as headers %}
{% import 'footers.html' as footers %}
{% import 'algo.html' as algo %}

<html lang="en">
	<head>
		<title>Counting Primes</title>
		{{ headers.meta() }}
	</head>
	<body>
		{{ headers.full_upper('Counting Primes', 'NumberTheory') }}
		<h2>Introduction</h2>
        <p>This article is focused on showing efficient techniques regarding prime counting or, in general, counting numbers coprime to some set of numbers. <!--Currently, Prime Number Theorem is assumed without proof. -->Here, \(P\) will refer either to set of all primes or sequence of subsequent primes (\(i\)-th element of this sequence will be denoted as \(P_k\)). Definitions used in this article:</p>
		<ol>
			<li><strong>Prime counting function \(\pi(n)\)</strong> is a function counting number of prime numbers \(p \in P\) in the interval \(\lt 1;n \gt\) inclusive.
				$$\pi(n)=|\{x: x \le n \land x \in P\}|$$
			</li>
            <!--<li><strong>Prime Number Theorem</strong> states, that:
				$$\lim_{n \rightarrow \infty} \frac{\Pi(n)}{n/\ln(n)} = 1$$
				There are at least two types of proofs of this theorem: refined analytical proofs using properties of zeta function or even more uncanny entities, and Selberg/Erdos standard proof - long, painful, one that can be interpreted as the very definition of suffering and could serve well as introduction to Schopenhauer's <i>The World as Will and Representation</i>. Currently, none is shown here.
			</li>-->
			<li><strong>Partial sieve function \(\phi(n, a)\)</strong> is defined as number of numbers lower or equal to \(n\) not divisible by any prime number in sequence \(P\) up to index \(a\).
				$$\phi(n, a)=|\{x: x \le n \land \forall_{i \le a} P_i \nmid x\}|$$
			</li>
			<li><strong>Kth partial sieve function \(P_k(n, a)\)</strong> is defined as number of numbers lower or equal to \(n\) not divisible by any prime number in sequence \(P\) up to index \(a\), that have \(k\) (not necessarily distinct) prime factors.
				$$P_k(n, a)=|\{x: x \le n \land \forall_{i \le a} P_i \nmid x \land x=p_1p_2 \dots p_k\}|$$
			</li>
		</ol>
		<h2>Problem I - Number of coprime numbers in a range, or special case of more general problem</h2>
		<p>A sequence \(S\) of \(m\) pairwisely coprime numbers \(m \le 100, S_i \le 10^5\) is given. How many there are numbers less or equal to \(n\) (\(n \le 10^{13})\) not divisible by any element of \(S\)?</p>
		<h3>Solution I: almost Legendre's formula</h3>
		<p>Let \(C_S(n)\) denote answer to given question. First, answer is equal to amount of numbers in a range except numbers divisible by at least one number from sequence. From inclusion-exclusion principle, 
		$$C_S(n) = n - \sum_{i=1}^{m} \lfloor \frac{n}{S_i} \rfloor + \sum_{i=1}^{m} \sum_{j=1}^{m} \lfloor \frac{n}{S_i S_j} \rfloor - \dots + (-1)^m \lfloor \frac{n}{S_1 S_2 \dots S_m} \rfloor$$
		Note that as all numbers are coprime, it is not necessary to calculate any \(lcm\) (otherwise there would be \(lcm(S_{i_1}, S_{i_2}, \dots S_{i_l})\) instead of \(S_{i_1} S_{i_2} \dots S_{i_l}\)
		</p>

		<p>How to estimate number of operations occuring using this technique? Let \(f(S,n)\) denote set of all multiples of elements of \(S\) lower or equal to \(n\). There are two banal ways: </p>
			<ol> 
				<li>One can invent maxtest for this particular problem where \(H=S\) consisits of 100 smallest primes, \(n=10^{13}\): turns out, that \(f(H, 10^{13}) \approx 2*10^9\) - too large.</li>
				<li>For any set \(S\) of size \(m\) one can estimate \(f(S, n)\) by \(O(\sum_{i=0}^{k} \binom{m}{i})\), where \(k\) is index of greatest primorial (primorial \(p_h\#\) is product of first \(h\) primes) lower equal to \(m\): here, it is equal to \(k=10\), as \(p_{10}\# = 200.560.490.130, p_{11}\#=7.420.738.134.810\) - because no more than \(k\) primes will be chosen for as denominators for this formula. This, however, does not necessarily yield better estimates than \(O(n)\).</li>
			</ol>
		</p>

		<h3>Solution II: generalized partial sieve function</h3>
		<p>
		Let \(\phi_S(n, a)\) denote amount of numbers in range \(\lt 1;n \gt\) coprime to all numbers in sequence \(S\) up to index \(a\):
			$$ \phi_S(n, a)=|\{x: x \le n \land \forall_{i \le a} S_i \nmid x\}| $$
			Note, that \(\phi(n, a)=\phi_P(n,a)\). How to calculate values of that function?
		</p>
		<p>All numbers not divisible by any element of \(S_1, \dots, S_a\) are all numbers not divisible by any element of \(S_1, \dots, S_{a-1}\) except those divisible by \(S_a\). As \(S_a\) is coprime to all previous elements, each element in range \(\lt 1; \lfloor \frac{n}{S_a} \rfloor \gt \) not divisible by \(S_1, \dots, S_{a-1}\) multiplied by \(S_a\) will yield a number:</p>
		<ol>
			<li>Not divisible by \(S_1 \dots S_{a-1}\)</li>
			<li>Divisible by \(S_a\)</li>
			<li>Lower or equal to \(n\)</li>
		</ol>
		<p>Conversely, if some number satisfies three points above, it can be obtained as product described above. Thus:
			$$\phi_S(n, a)=\phi_S(n, a-1)-\phi_S(\lfloor \frac{n}{S_a} \rfloor, a-1)$$
			$$\phi_S(n, 0)=n$$
		</p>
        <p>Also, notice, that \(\lfloor \frac{\lfloor \frac{n}{ a } \rfloor}{b} \rfloor = \lfloor \frac{n}{ab} \rfloor\) where \(n,a,b \in N\) - to show it, let \(n=kab+la+m\), where \(la+m \lt ab\), also \(k,l,m \in N \cup \{0\}\) and \(m \lt a\)
		$$ \lfloor \frac{\lfloor \frac{n}{ a } \rfloor}{b} \rfloor = \lfloor \frac{\lfloor \frac{ kab+la+m }{ a } \rfloor}{b} \rfloor = \lfloor \frac{kb+l}{b} \rfloor = $$
		$$ = k = \lfloor \frac{kab}{ab} \rfloor = \lfloor \frac{kab+al+m}{ab} \rfloor = \lfloor \frac{n}{ab} \rfloor$$
		</p>
		<p> And the sought value is \(\phi_S(n, |S|)\). While this formula is immediate consequence of Legendre's formula, it gives the possibility to reformulate the solution in moderately elegant way:</p>
		<ol>
			<li>Below, \(\frac{a}{b}\) will mean \(\lfloor \frac{a}{b} \rfloor\).</li>
			<li>Let \(m=|S|\) - length of sequence \(S\). First, let the formula be reformulated:
				$$ \phi_S(n, m)=\phi_S(n, m-1)-\phi_S(\lfloor \frac{n}{S_m} \rfloor, m-1) = $$
				$$ = \phi_S(n, m-2)- \phi_S(\lfloor \frac{n}{S_{m-1}} \rfloor, m-2) - \phi_S(\lfloor \frac{n}{S_m} \rfloor, m-2) + \phi_S(\lfloor \frac{n}{S_m S_{m-1}} \rfloor, m-2) = \dots = $$
				$$ = \phi_S(n, 0) - \sum_{i} \phi_S(\lfloor \frac{n}{S_i} \rfloor, 0) + \sum_{i,j} \phi_S(\lfloor \frac{n}{S_i S_j} \rfloor, 0) - \dots + (-1)^m \phi_S(\lfloor \frac{n}{S_1 \dots S_{m}} \rfloor, 0) = $$
				$$ = n - \lfloor \frac{n}{S_i} \rfloor + \sum_{i,j} \lfloor \frac{n}{S_i S_j} \rfloor - \dots + (-1)^m \lfloor \frac{n}{S_1 \dots S_{m}} \rfloor$$
			</li>
			<li>Let <i>\(i\)-th Layer</i> denote all \(\phi(w, i)\) for some \(i\), that appeared in formula above; also, let \(L_i\) denote set of all \(w\) appearing in the \(i\)-th layer.</li>
			<li>Implementation-wise, it may be worth noticing, that \(L_i \subseteq L_{i-1}\) - because \(\phi_S(w,i)\) splits to \(\phi_S(w, i-1)\) and \( \phi_S(\lfloor \frac{w}{S_i} \rfloor, i-1)\).</li>
            <li>Street-wise, \(|L_i| \le 2 \sqrt{n}\) - because there are \(\sqrt{n}\) possible values of \(g=\lfloor \frac{n}{h} \rfloor\) for any \(h  \le \sqrt{n}\) (namely \(\{n, \frac{n}{2}, \dots \frac{n}{\sqrt{n}}\}\); and \(\sqrt{n}\) possible values of \(g\) for \(h \gt \sqrt{n}\) (namely \(\{0, 1, 2, \dots \lceil \sqrt{n} \rceil \}\).</li>
			<li>This leads to a simple algorithm: for all \(w\) in \(W=\{0, 1, 2, \dots, \lceil \sqrt{n} \rceil \} \cup \{n, \frac{n}{2}, \dots \frac{n}{\sqrt{n}}\}\) calculate \(\phi_S(w, 0), \phi_S(w, 1), \dots \phi_S(w, m)\), layer by layer. Complexity will be limited from above by \(O(m \sqrt{n})\) - in case of this problem, about \(10^8\) operations.</li>
			<li>One can go a bit further - calculate values in \(L_i\) as values used in \(L_{i+1}\) and elements from \(L_i\) divided by \(S_i\) - complexity remains identical, but the amount of operations will be significantly lower - especially, if one sorts \(S\) beforehand (so that \(S_i \lt S_{i+1}\)) and uses two pointers to construct new layer in linear time.</li>
			<li>Constructing new layer; suppose, one has sorted in ascending order elements from \(L_i\), and one wants to construct \(L_{i-1}\). Then, let \(p1, p2\) be pointers pointing to some elements in sorted \(L_i\), at the start both equal to 0. Then, depending on situation:
				<ol>
					<li>\(L_i(p2)\) does not exist; then \(L_i(p1)\) shall be added at the end of representation of \(L_{i-1}\), and \(p1+=1\).</li>
					<li>\(\frac{L_i(p2)}{S_i}\) is at the end of current representation of \(L_{i-1}\): \(p2+=1\).</li>
					<li>\(\frac{L_i(p2)}{S_i} \lt L_i(p1)\) - then \(\frac{L_i(p2)}{S_i}\) shall be added at the end of representation of \(L_{i-1}\), and \(p2+=1\).</li>
					<li>\(\frac{L_i(p2)}{S_i} \gt L_i(p1)\) - then \(L_i(p1)\) shall be added at the end of representation of \(L_{i-1}\), and \(p1+=1\).</li>
					<li>\(\frac{L_i(p2)}{S_i} = L_i(p1)\) - then \(L_i(p1)\) shall be added at the end of representation of \(L_{i-1}\), and \(p1+=1, p2+=1\).</li>
				</ol>
				"representation" refers to sorted sequence of elements of \(L_i\).
			</li>
			<li>\(\phi(w,i)\) has to be calculated if and only if \(w \in L_i\).</li>
		</ol>
		{{ algo.neo_algorithm(1, 'Calculating \(\phi(n, a)\)', '
			<p></p>
		'
		, '121 7', {'color_description':{'standard':'', 'change':'', 'crucial':'Value \(\phi(n,a)\) to calculate'} }) }}

		<h2>Problem 2: number of primes in a range</h2>
		<p>A number \(n \le 10^{11}\) is given; how many there are primes in range \(\lt 1;n \gt\)?</p>
		<h3>Solution I: Legendre's formula</h3>
		<p><strong>Legendre's formula</strong> states, that:</p>
		{% set sqrt=" \lfloor \sqrt{n} \\rfloor " %}
		$$ \pi(x) = -1 + \pi( {{sqrt}} ) + n - \sum_{p_i \le {{sqrt}} } \lfloor \frac{n}{p_i} \rfloor + \sum_{p_i \le p_j \le {{sqrt}} } \lfloor \frac{n}{p_i p_j} \rfloor + \dots + (-1)^{ k } \lfloor \frac{n}{p_1 p_2 \dots p_k} \rfloor$$

		<p>Where:</p>
		<ol>
			<li>\(\pi( {{sqrt}} )\) counts number of all primes in range up to \({{ sqrt }}\)</li>
			<li>\(n - \sum_{p_i \le {{sqrt}} } \lfloor \frac{n}{p_i} \rfloor + \sum_{p_i \le p_j \le {{sqrt}} } \lfloor \frac{n}{p_i p_j} \rfloor + \dots + (-1)^{ {{sqrt}} } \lfloor \frac{n}{p_1 p_2 \dots p_k} \rfloor\) counts all numbers not divisible by any found prime - as in the first problem.</li>
			<li>\(-1\) stands for counting number \(1\) - neither prime, nor divisible by any prime. 
		</ol>
		<p>It suffers from same problems as analogous method shown in problem I - its number of operations is too great.</p>
		<h3>Solution II: partial sieving</h3>
		<p>First, the problem will be divided into two distinct problems:</p>

        {% set partial_sq=" n^{1/L} " %}
		<ol>
			<li>How many there are numbers in range \(\lt 1;n \gt\) not divisible by prime numbers \(p \le {{partial_sq}} \) for some \(L\)?</li>
			<li>How many there are numbers in range \(\lt 1;n \gt\) divisible by either \(2\) or \(3\) or \(\dots\) or \(k\) primes, all of them greater than \( {{partial_sq}} \)?</li>
		</ol>
		<p>First problem can be defined in terms of a partial sieve function:
			$$\phi(n, \pi( {{partial_sq}} ))$$
		gives the sought result.</p>
		<p>Let \(P_k(n, a)\) be defined as amount of number lower equal to \(n\) with exactly \(k\) prime divisors (not necessarily distinct), none of them less or equal to \(P_a\). Then:
			$$\phi(n, h)=P_0(n, h) + P_1(n, h) + P_2(n, h) + \dots $$
		</p>
		<p>How to calculate \(P_k(n, a)\) though? The banal solution, for \(k \ge 2\):
		$$P_k(n, a)=\sum_{i_1=a+1}^{\pi(n^{1/2})} \sum_{i_2=i_1}^{\pi(n^{1/2})} \dots \sum_{i_{k-1}=i_{k-2}}^{\pi(n^{1/2})} MAX(\pi(\frac{n}{P_{i_1} P_{i_2} \dots P_{i_{k-1}}}) - i_{k-1}, 0) $$
		It counts, for each possible result of multiplying \(k-1\) primes, where \(P_{i_v} \le P_{i_v+1}\), in how many ways last prime (that may be greater than \(n^{1/2}\), and has to be greater or equal to \(P_{i_{k-1}}\)) can be chosen?
		</p>
		<p>One can move a bit further - arguing, that, if \((P_{i_1} \le P_{i_2} \le \dots \le P_{i_k})\), then, better bounds on each \(i_x\) may be placed: </p>
		<ol>
			<li>What is smallest possible \(P_{i_1}\)? It is equal to \(P_{a+1}\).</li>
			<li>When is \(P_{i_g}\) largest? When \(P_{i_1} \le P_{i_2} \dots P_{i_{g-1}} = P_{a+1} \ge n^{1/L}\), and \(P_{i_g} = P_{i_{g+1}} = \dots P_{i_k}\)</li>
			<li>The product of \(P_{i_g} P_{i_{g+1}} \dots P_{i_k} \le n^{1-(g-1)L}\) - because product of those values has to be lower than \(\frac{n}{P_{i_1} P_{i_2} \dots P_{i_{g-1}}}\)</li>
			<li>Thus, single element of this product \(P_{i_g} \le n^\frac{ {1-(g-1)L} }{k-g+1}\)</li>
		</ol>
		<p>The above allows to represent the formula for \(P_k(n,a)\) in a different way:
		$$P_k(n, a) = \sum_{i_1=a+1}^{\pi(n^{1/k})} \sum_{i_2=i_1}^{\pi(n^{\frac{1-1/L}{k-1} }) } \dots \sum_{i_{k-1}=i_{k-2}}^{\pi(n^{1-(k-1)/L}) }  MAX(\pi(\frac{n}{P_{i_1} P_{i_2} \dots P_{i_{k-1}}}) - i_{k-1}, 0) $$
		In general, presenting formula in this form does not seem to be extremely bright idea - it will be discussed as a special case of applying the above.
		</p>

		<p>Another problem: many values of \(\pi(x)\) have to be calculated to use this formula; to solve this problem, one can use standard erastotenes sieve. The greatest amount of primes has to be sieved when finding \(P_2(n, a)\) - namely, \(\pi(\frac{n}{P_a})\) - thus, for certain \(L\), \(\pi(n^{1-1/L})\) has to be calculated in something like \(O(n^{1-1/L} \log\log(n))\).</p>
		<h4>Particular application of ideas above</h4>
		<p>Say, \(L=4\) - then:</p>
		<ol>
			<li>Complexity of calculating \(\phi(w,i)\) can be limited by \(O(\sqrt{n}n^{1/L}) = O(n^{3/4})\) - or, if someone believes in Prime Number Theorem, even \(O(\frac{n^{3/4}}{\log(n)}</li>
			<li>One has to construct a sieve of size \(O(n^{1-1/4}=O(n^{3/4})\) - complexity is equal to \(O(n^{3/4} \log \log(n))\).</li>
			<li>To calculate 
				$$ P_2(n, \pi(n^{1/4})) = \sum_{i=\pi(n^{1/4})+1}^{\pi(n^{1/2})} \pi(\frac{n}{P_i})$$
			One has to do \(O(n^{1/2})\) operations.</li>
			<li>To calculate 
				$$ P_3(n, \pi(n^{1/4})) = \sum_{i_1=\pi(n^{1/4})+1}^{\pi(n^{1/3})} \sum_{i_2=i_1}^{\pi(n^{3/8})} \pi(\frac{n}{P_{i_1} P_{i_2} })$$
				(note, that \(\frac{1-1/4}{3-2+1} = \frac{3}{8}\) - a value present in the formula above) one has to do \(O(n^{1/3+3/8}) = O(n^{17/24}) \lt O(n^{3/4})\) operations.
			</li>
		</ol>
		<p>To summarize, if \(a=\pi(n^{1/4})\), the sought result can be expressed as
			$$ \pi(n) = a + \phi(n, a) - P_2(n, a) - P_3(n, a) $$
		 as all values \(P_4(n, a), P_5(n, a), \dots\) are equal to 0.
		</p>
		<p>So, the complexity of this algorithm is \(O(n^{3/4} \log \log n)\).</p>
        <h3>Solution III: It's been years, since persistent segment trees came in</h3>


		<h2>Summary</h2>
		<ol>
			<li>\(\phi(n,a)=\phi(n, a-1)-\phi(\frac{n}{P_a}, a-1)\) - a number of primes not divisible by primes up to \(P_a\) is equal to number of numbers not divisible by primes up to \(P_{a-1}\) except for numbers divisible by \(P_a\) and not divisible by any lower prime.</li>
			<li>One can calculate \(\phi(n,a)\) in \(O(a\sqrt{n})\) - because for any \(x \le a\) only \(O(\sqrt{n})\) values of \(\phi(h,x)\) for some \(h\) have to be calculated from the formula.</li>
			<li>To count all primes in a range, also functions counting amount of numbers having 2 or 3 primes (not necessarily distinct) in their factorization might come in handy. To allow simple calculations of values of those functions, one can utilize sieve of erastothenes.</li>
		</ol>
		<h3>Problems</h3>
		<p>Most problems involving techniques described above usually ask about divisibility of numbers belonging to a large (with size \(\gt 10^9\)) interval. Examples include:</p>
		<ol>
			<li><a href="https://codeforces.com/problemset/problem/93/E">Lostborn</a></li>
			<li><a href="https://codeforces.com/problemset/problem/665/F">Four Divisors</a></li>
		</ol>




		<!--
			as \(\pi( {{partial_sq}} ) \approx 10^3 \), setting constant \(C\) for dp/recursion tradeoff to \(10^3\) seems to be a reasonable
		-->
		

		<div id="problems"></div>
		<button class="sender" id="taskButton" name="next" type="submit" formmethod="post" form="page" value="taskAdder" style="display:none;">Add Problem</button>
		<script src="{{url_for('static', filename='Prcount.js')}}"></script>
		<form id="page" style="display:none"></form>
		{{ footers.full_lower() }}
	</body>
</html>
